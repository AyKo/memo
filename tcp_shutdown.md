# TCPを閉じる場合はshutdown()を使う

## 動機
TCP通信を閉じるためにソケットのファイルディスクリプタに対してclose()を呼び出したが、ESTABLISHEDのままになっている。

## 回答
close()の前にshutdown()を使う。

shutown()を使えば、後述する理由でclose()を呼び出してもFINを送信できずESTABLISHEDから抜けられない場合でも、ESTABLISHEDから抜ける(FIN_WAIT1になる)。

close()を呼び出してもESATBLISHEDにとどまってしまうのは、以下の２つの原因の少なくともどちらか一方が発生していると思われる：
1. 子プロセスとソケットのファイルディスクリプタを共有している
2. 送信バッファにデータが残っている

### 子プロセスとソケットのファイルディスクリプタを共有している
複数のプロセスでファイルディスクリプタが共有されている場合は、共有しているすべてのプロセスでclose()しなければファイルディスクリプタが閉じない。

OSはファイルディスクリプタ共有されている数を管理していて（参照カウント）、誰からも参照されなくなって初めて解放される。TCPソケットのファイルディスクリプタの場合、解放された時点で通信終了（ESTABLISHEDから抜ける）となるため、注意が必要である。
（もっとも、子プロセスとTCPソケットの共有をしないと分かっている場合は、close-on-execを用いて子プロセスと共有しないように指定したほうがよい）

もし、子プロセスとファイルディスクリプタを共有していた場合でも、shutdown()を用いればFINを送信して通信を終了する。

### 送信バッファにデータが残っている
OSは送信バッファにデータ残っている場合はFINは送信しない。FINは通信終了を意味するものなので、データを送信し終わらないと送信できないからである。そうするとTCPの状態はESTBLISHEDに留まることになる。

この場合の弊害としては、送信データ準備待ちとしてpoll()やselect()などを用いている場合にclose()したとしても通信の終了を検出できないことがある。もし、通信相手が例えばバグにより、データの受信をしないままかつソケットも閉じなかったとする（FINもRSTも送信しない）。この場合、相手側の挙動に巻き込まれていつまでも送信準備待ちのpoll()から抜けられなくなってしまう。（この状態の場合、プロセスからはファイルディスクリプタを閉じているのでそのソケットに一切アクセスできないのにも関わらずブロックし続ける）

もし、送信バッファにデータ残っている場合でFINが送信できない場合でも、shutdown()を呼び出すとFIN_WAIT1に状態遷移をする。そうすれば、送信準備待ちのpoll()から抜けることができる。
