# 不正終了時のシグナル

## 動機
プロセスが不正終了した。
SIGSEGVというシグナルで終了したらしい。これで何が分かるか。
また、不正終了時に通知されるシグナルはどんな種類があるか。

## 回答
Linuxには数多くのシグナルがあるが、プログラムの不正終了時に我々が遭遇するシグナルは数種類をしかないと思ってよい。
例えば、SIGSEGVは不正メモリアクセスを意味する。
どのシグナルで終了したかが分かれば、原因についてある程度の推測ができる。

### 不正終了時の頻出するシグナル
- SIGSEGV  
  メモリの不正アクセスすると起こる。
- SIGABRT  
  abort()を呼び出すと起こる。ライブラリ内、例えばmalloc呼び出し時に管理領域に不正を検出したりしても呼ばれるようになっている。
- SIGPIPE   
  すでに相手が読めない事ことが分かっているファイルディスクリプタに書き込みをした場合に起きる。Coreダンプが出力されないので注意する。

### 次点で発生しがちのシグナル
- SIGHUP  
  そのプロセスが端末に割り当てられている際にその端末が閉じた際に起こる。Coreダンプが出力されないので注意する。
- SIGFPE  
  ０除算で起こる。

### 終了するが意図して送信されただろうシグナル
意図をもって、例えば操作によって送信した場合が主であるシグナル。いずれもCoreダンプは出力されない：
- SIGTERM  
  『kill <PID>』コマンドを実行した際に発生する。
- SIGKILL  
  『kill -KILL <PID>』コマンドを実行した際に発生する。メモリ不足でカーネルから送信されることもある。
- SIGINT   
  実行した端末でCtrl-Cを押した際に発生する。

### SIGSEGV
メモリの不正アクセスすると起こる。

メモリの不正アクセスとは、正確には仮想メモリ上でアクセス不能なアクセスのことをいう。
例えば、一見不正アクセスにみえるアクセスでも、仮想メモリ上に割り当てられていれば不正アクセスにならない。
また、各アドレスにはアクセス権が設定されており、例えば書き込み不可のアドレスは読み込んでもSIGSEGVにならない。
よって、間違ったメモリアクセスをしたら必ず発生するものではないと考えること。

仮想アドレス上のメモリ配置・アクセス権はpmapコマンドで確認できる。

例）以下のプログラムについて、私が確認した環境では(2)(4)ではSIGSEGVが起こる。(1)(3)では起きなかった。

    unsigned char *p;
    unsigned char c;

    p = malloc(16);
    p[128 * 1024] = 0; // (1)
    p[132 * 1024] = 0; // (2)
        
    p = (unsigned char*) 0xffffffffff600000;  // vsyscall領域[r-x]
    c = p[0]; // (3)
    p[0] = 0; // (4)


(1)は明らかに確保した領域を超えていて不正アクセスといえるが、SIGSEGVは発生しなった。
アクセスしたアドレスは、malloc()の機構が事前に確保したアドレスに含まれているため、
実施差には仮想アドレス上にマッピングされている。

(2)は仮想メモリ上にマッピングされておらずSIGSEGVによって終了する。

vsyscallと言われる領域は、読み込みと実行は可能だが書き込みができない。
よって、(3)では問題ないが、(4)ではSIGSEGVが起こる。

### SIGABRT
abort()を呼び出すと起こる。

我々が記述するプログラム内では、続行不能な致命的な問題が発生したと判断したロジック上に組み込むことがある。
標準で準備してあるライブラリ内でもあえて呼ばれる場合がある。

例）以下のプログラムについて、私が確認した環境ではfree()を呼び出した際にライブラリに内でabort()を呼び出しSIGABRTで終了した。

	unsigned char* p = malloc(16);
	memset(p - 16, 0, 16);
	free(p);

malloc()の管理領域を壊した後でfree()を呼び出した。free()の内部で異常を検出してSIGABRTが起きて終了した。

### SIGPIPE
すでに相手が読めない事ことが分かっているファイルディスクリプタに書き込みをした場合に起きる。
プログラムが不正終了するがCoreダンプがない場合の主な原因の一つ（≪プログラムが不正終了するがCoreダンプがない≫参照）。

例えば、TCPでソケット通信しているプログラムにて、通信中に相手がそのソケットを閉じたとする。
そのまま（タイミング的に検出が不可能な場合はある）、そのソケットでデータを送信しようとするとSIGPIPEが起こる。
TCP以外でも、単にprintf()をしていてその出力先が閉じたりすると発生する（例参照）。
我々のプログラムにおいては、特殊な場合を除きSIGPIPEを無視するように指定すること。

例）単に文字列を出力し続けるsampleプロセスがあるとする。
さらに、sampleプロググラムをパイプしてsedコマンドにつなげる。ここで、パイプが閉じるようなことがあるとSIGPIPEが発生する。

    $ ./sample | sed '10q'
　
sedは10行目で終了する。終了後、次の文字列の出力タイミングでsampleプロセスは、出力先から切断された標準出力に書き込むことになる。そうするとSIGPIPEが発生する。

## 参考情報
man 7 signal
