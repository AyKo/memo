# NETSTAT: 使っているTCP・UDPの状態を知りたい

## 動機
プログラムが用いているTCP・UDPの状態を知りたい。
また、この表示で単にTCP・UDPを用いてる、TCPがつながっている/いない以上のことが分かるか。

## 回答
```netstat -antup``` を用いる。

該当マシンで用いているTCPとUDPの情報を表示する。
TCPとUDP、およびTCPの状態の基本的に説明はここでは割愛する。

通常、待ち受けているべきポートがあるかどうか(LISTEN)、接続状態になっているべき対象が接続しているか(ESTABLISHED)を確認する。
他にも異常状態が分かることがある。
我々の環境においては、以下がnetstatコマンドでわかる異常のパターンのうち頻出するが分かりづらいものとして：
- Recv-Qが恒常的に0以上
- Send-Qが恒常的に0以上
- CLOSE-WAITがある
- ESTABLISHED/CLOSE-WAITだがPIDが割あたってない

がある。

### Recv-Qが恒常的に0以外になっている
プログラム問題があって受信処理をおこなっていないことを疑う。

Recv-Qは、相手からデータを受信しOSのキューにたまっているデータのバイトサイズを示す。プログラムで受信(read()、recv()など)することは、実際にはこのキューからデータを取り出すことを示す。
よって、Recv-Qの値が0にならない状態は、プログラム問題があって受信処理をおこなっていない。

### Send-Qが恒常的に0以外になっている
TCP接続後にネットワーク的に問題が発生して通信不能になっているか、通信相手側で受信処理がおこなわれていないことを疑う。

Send-Qは、相手に送信待ちのバイトサイズを示す。
特にTCPにおいては、相手に届いたかどうかをプロトコルで保証しようとするので、この値が相手に届いたかどうかの目安になる。
プログラムで送信(write()、send()など)することは、実際にはこのキューにデータを入れることを示す（つまり、関数の戻り値がそれらしい値になっていたとしても、相手に届いたことを意味するわけではないことを示す）。
よって、Send-Qの値が0にならない状態は：
- ネットワーク的に問題が発生している(TCP-ACKが返ってこない)か、
- 相手側で受信処理がおこなわれていない(相手側のRecv-Qがいっぱいの状態になっている)

ことが推測できる。

UDPにおいては、プロトコル的に転送制御がないためSend-Qが恒常的に0以上になっていることは通常ない。

### CLOSE-WAITが残っている
プログラムに問題がってソケットをclose()していないことを疑う。

TCPの状態CLOSE-WAITは、相手がTCPを閉じたが、自分側のプログラムがTCPを閉じていない状態を示す。
よって、CLOSE-WAITが残っている状態は、プログラムに問題があってソケットをclose()していないことを示す。

### ESTABLISHED/CLOSE-WAITだがPIDが割あたってない
（一般権限でnetstatした場合は、権限の問題でPIDが分からなかっただけかもしれないので注意）

TCPサーバ側のプログラムで問題があってaccept()していないことを疑う。

その通信についてPIDが割り当ている状態は、そのプロセスからその通信の制御が可能なことを示す。
逆に割あたっていない状態は、どのプロセスからも制御されない(できない)状態を示す。
ここで、例えば自プログラムがTCPサーバの場合で、TCP接続をされているがaccept()していない場合はどのプロセスからも制御していないので、
PIDが割あたっていない状態になる。

よって、ESTABLISHED/CLOSE-WAITだがPIDがない状態は、プログラムに問題があってacceptしていないことを示す。
なお、CLOSE-WAITかつPIDがない場合は、accept()していないまま相手から切断された状態を示す。
