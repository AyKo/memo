# TCPでネットワークの断絶を想定する

## 動機
ネットワークの断絶の発生を想定しなければならない。
一時的な通信中断やデータ破棄が発生するのは仕方ないとしても、その後に通信は復旧できなければならない。
どう考えればよいか。

## 回答
特に頻出する欠陥として、特に対処せずともどんな状況でもOSがTCPの切断を検出できるとする（と考えたとしか思えない）設計である。こういった設計の場合、ネットワークの断絶が発生した結果、TCPの切断を延々と待ち続けて何もできなくなってしまうことがある。

対処としては以下を組み込んでおく：
- ネットワーク断絶を検出できる仕組みをいれておく  
  通信のヘルスチェックを設計に組み込むか、TCP KeepAlive を設定する
- TCPサーバ側はどんな場合でも２つ目の接続が発生しうると考えておく  
  通信対象アプリケーションとのプロトコル上TCPのサーバ側も単一セッションの通信のみで良い場合であっても、２つ以上のコネクションが発生する場合があると考え、新しいコネクションが発生したら動作させる
- 送信する場合、OSのキューの空き待ちで停止してしまうことを想定する  
  select()やpoll()などを使うか、SO_RCVTIMEO・SO_SNDTIMEOを用いる。（※select()を使う場合は重大な欠点があることに注意すること）

## ネットワーク断絶を検出できる仕組みをいれておく
アプリケーションのプロトコルレベルでネットワーク断絶を検出できるように、俗にヘルスチェックと呼ばれる定期的に通信する仕組みをいれておくかTCP KeepAliveを適切なパラメータで設定すること。

　我々の環境においては、おおむねアプリケーションのプロトコルレベルでネットワーク断絶を検出できるように、俗にヘルスチェックと呼ばれる定期的に確認・応答がある通信する仕組みをいれることが常套手段になっている。その仕組みを組み込むことで、応答の有無でネットワーク断絶を検出できる。

　あるいは、TCP KeepAliveを用いてTCPプロトコルレベルで断絶を検出させる。KeepAliveの時間は、初期設定が非常に長い間隔であったことに加え、古いOSではOS全体単位でしか設定できなかったことから避けがちであった。しかし、現在ではソケット単位に設定できるようになっているので有用な選択肢になる。

### TCPサーバ側はどんな場合でも２つ目の接続が発生しうると考えておく
　通信対象アプリケーションとのプロトコル上で同時には１つしかTCPコネクションが発生しないとする通信を取り扱っていたとしても、新しいTCPコネクションが有効であると考えること。accept()したTCPセッションが有効であっても、listen()したファイルディスクリプタも常に監視すること。

　我々のプログラムにおいて、通信対象アプリケーションとのプロトコル上で同時には１つしかTCPコネクションが発生しないとする通信を取り扱っていたとする。ここで、ネットワーク断絶などによって切断が検出できなかったが、通信対象側は切断を検出していて新しいコネクションを開始したとする。そうすると、先のTCPコネクションが切断せずに新しいTCPコネクションが発生することになる。
　この新しいTCPコネクションはプログラム側がaccept()を呼び出していなったとしても、確立(ESTABLISHED)まではOSがおこなうので、通信対象アプリケーションとしては接続が完了する。TCPクライアント側が、開始したTCPコネクションがaccept()されたかどうかをまっとうに知る手段は存在しない。
　そうすると、プログラム側は先の(すでに無効な)TCPコネクションの通信または切断を待っているが、通信対象アプリケーションは新しいTCPコネクションで通信準備ができているちぐはぐな状態になる。

### 送信する場合、OSのキューの空き待ちで停止してしまうことを想定する
　送信する場合はselect()やpoll()などを使うか、SO_RCVTIMEO・SO_SNDTIMEOを用いること。（※selectを()使う場合は重大な欠点があることに注意すること）

　TCPで送信(write()、send()など)とは、該当TCPセッションのSend-Qにデータを格納することを意味する（≪使っているTCP・UDPの状態を知りたい≫を参照）。ここで、Send-Qが一杯になると、write()、send()は失敗ではなく空きができるまで停止をする（ブロッキングモードの場合）。

### selectの()欠陥（poll()を使う）
　前述したselect()の欠陥について述べる。select()で待ち受けているファイルディスクリプタが、別スレッドでクローズした場合は、どのような結果になるか規定されていないとのこと。私の調査では、select()から抜けることができなくなった。
　別スレッドでファイルディスクリプタをクローズする可能性がある場合でselect()を用いる場合、代替えとしてpoll()を使う。

## 参考情報
[man 2 select](https://linuxjm.osdn.jp/html/LDP_man-pages/man2/select.2.html)  
（※RHEL6のmanページには、select() のマルチスレッド下で欠陥が記載されていない）
