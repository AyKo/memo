# Coreダンプ調査（基本）

## 動機
Coreダンプを採取した。どうすればよいか。

## 回答
gdb を使ってCoreダンプを開く。

開いた後、不正終了によるCoreダンプなら、最初に「bt」コマンドで不正終了を検出したスレッドのバックトレースを表示する。
gcoreコマンドで取得したCoreダンプなら、全スレッドのバックトレースを表示する「thread apply all bt」コマンドを実行する。
これで、概ね、少なくとも直接原因は分かることが多い。

Coreダンプと実行ファイルを指定して起動すると、各スレッド、変数の値、プログラムが不正終了したのならばどこでダウンしたかなどを確認できる。
ただし、プログラムのデバッグ情報が必要である。
「Coreダンプ調査（準備）」で述べたようにdebug-infoがインストールしてあるとさらによい。

### gdbでのCoreダンプの開き方

    gdb -c <coreファイル> <実行ファイル>

もし、strip -dでデバッグ情報を削除していれば、削除していない実行ファイルを指定する（[デバッグ情報付きの実行ファイル](executable_with_debug_info.md)参照）。

### プログラムの不正終了
プログラムが不正終了した際に採取したCoreダンプを開いたのならば、プログラムのどの部分で終了したかが分かる。
- その直接の要因（どのシグナルで終了したか）
- どの処理で終了したか

例）Coreダンプを開いた

    $ gdb -c core.3904 testprogram 
    …
    Core was generated by `./testprogram'.
    Program terminated with signal 11, Segmentation fault.
    #0  0x00007f135dbc19be in memcpy () from /lib64/libc.so.6
    Missing separate debuginfos, use: debuginfo-install glib2-2.28.8-10.el6.x86_64 glibc-2.12-1.212.el6.x86_64
    (gdb)
	
Signal 11(SIGSEGV)でダウンしているので、メモリの不正参照で終了していること分かる。
testprogram.cの27行目のmemcpy()が直接の問題とのこと。

### バックトレースと原因の調査
gdbには多くのコマンドがあるが、いくつかのコマンドを知っていればおおむね原因の調査はできる。以下に、把握しておくべきコマンドを示す。カッコ書きは略称である。

- backtrace (bt)  
  コールスタック（関数呼び出し履歴）の表示
- print (p)  
  変数などの表示
- frame (f)  
  コールスタックを移動
- x  
  メモリダンプ
- info thread  
  全スレッドの表示
- thread(th)  
  スレッドの移動
- thread apply all bt  
  全スレッドのコールスタックを表示
- maintenance info sections  
  メモリマップの表示
	
#### 例）コールスタックの表示

    (gdb) bt
    #0  0x00007f135dbc19be in memcpy () from /lib64/libc.so.6
    #1  0x0000000000400b48 in message_receiver_thread (arg=0x1deb8e0) at testprogram.c:27
    #2  0x00007f135e1533e4 in ?? () from /lib64/libglib-2.0.so.0
    #3  0x00007f135ded3aa1 in start_thread () from /lib64/libpthread.so.0
    #4  0x00007f135dc20c4d in clone () from /lib64/libc.so.6

Signal 11(SIGSEGV)でダウンしているので、メモリの不正参照で終了していること分かる。
testprogram.cの27行目のmemcpy()が問題と思われる。


#### 例）コールスタックの移動・変数表示

    (gdb) f 1
    #1  0x0000000000400b48 in message_receiver_thread (arg=0x1deb8e0) at testprogram.c:27
    27                      memcpy(copydata, msg->data, msg->size);
    (gdb) p copydata
    $1 = (uint8_t *) 0x7f1345fff010 ""
    (gdb) p *msg
    $2 = {size = 167772426, data = 0x7f13500008c0 "\n\001"}
	
	
フレーム1（#1  testprogram.c:27）に移動し、変数copydataとmsgを表示した。何となくmsg->sizeの値が多すぎる気がする。
デバッグとしては、msg->sizeを設定した部分がどこで、それがどうしてかを調べることになる。
直接の原因としてはほとんど確定だが、もう少し確認する。

#### 例）memcpy()のdstアドレスの確認

    (gdb) f 1
    #1  0x0000000000400b48 in message_receiver_thread (arg=0x1deb8e0) at testprogram.c:27
    27                      memcpy(copydata, msg->data, msg->size);
    (gdb) p copydata 
    $3 = (uint8_t *) 0x7f1345fff010 ""
    (gdb) p msg->data
    $4 = 0x7f13500008c4 ""
    (gdb) maint info sec  
    …
    0x01de9000->0x01e0a000 at 0x00004000: load3 ALLOC LOAD HAS_CONTENTS
    0x7f1345fff000->0x7f1350000000 at 0x00025000: load4 ALLOC LOAD HAS_CONTENTS
    0x7f1350000000->0x7f1350021000 at 0x0a026000: load5 ALLOC LOAD HAS_CONTENTS
    0x7f1350021000->0x7f1350021000 at 0x0a047000: load6 ALLOC READONLY
    0x7f1358000000->0x7f1358021000 at 0x0a047000: load7 ALLOC LOAD HAS_CONTENTS
    0x7f1358021000->0x7f1358021000 at 0x0a068000: load8 ALLOC READONLY
    0x7f135c736000->0x7f135c737000 at 0x0a068000: load9 ALLOC LOAD READONLY HAS_CONTENTS
    …

memcpyのsrcのアドレスについて、msg->size分のメモリが仮想メモリ上に用意されていないことが分かる。
msg->dataは0x7f13500008c4 だが、0x7f1350021000以降のアドレスが仮想メモリ上にない。その差は132924しかなく、msg->sizeの167772426分が格納には不足している。

## 参考情報

gdbの使い方、不正終了時のgdbでの調査の方法
- 吉岡弘隆、大和一洋、大岩尚宏、安部東洋、吉田俊輔（2009）『Debug Hacks―デバッグを極めるテクニック＆ツール』オライリー・ジャパン

バグをどう絞り込むかなどの系統的なアプローチ
- Andreas Zeller（2012）『デバッグの理論と実践　―なぜプログラムはうまく動かないのか』オライリー・ジャパン
